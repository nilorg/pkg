1. 缓存雪崩
大量缓存在同一时间失效
解决方法：设置缓存时间为范围随机，解决大量缓存在同一时间失效的问题。
2. 缓存穿透
缓存和数据库中都不存在（请求数据没有被缓存拦截，一直都在查询数据库，但是数据库没有，所以会一直找）

解决方法：当第一次命中时，如果没有数据会先查询数据，数据库没有查询到数据后设置该缓存 value 为 NOT_FOUND，之后每次都只会打到该缓存上，执行添加数据时把key进行删除
3. 缓存击穿

缓存击穿是指在缓存失效的时刻，大量的请求过来，回被同时打到下游，给下游造成瞬时压力，解决的办法就是只允许少量的请求打到下游，然后回填到缓存，其他请求还是从缓存拿数据。

解决办法一，使用分布式锁，确保只有一个请求获取到这个锁，其他请求去轮训缓存。特点是，为了保护下游，伤害了自己和redis，因为大量的请求停留在这里造成内存和CPU升高，但是大家都知道，接口服务器的性能不是问题，所以这个方案可行。

此处主要介绍方案二，那就是单飞模式 SingleFlight，在 golang 中有对应的实现 golang/groupcache ，它跟方案一的区别是讲分布式的锁改成了内存锁，没有了轮训redis这个操作；其次就是打到下游的请求要多一点，但是不构成压力。

解决方法：使用互斥锁，有锁时，等待获取。或可以使用SingleFlight请求合并/分布式锁
