package mq

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/nilorg/sdk/mq"
	"github.com/streadway/amqp"
)

// https://www.cnblogs.com/fone933/p/8284785.html
// 广播模式：1对多，produce发送一则消息多个consumer同时收到。
// 注意：广播是实时的，produce只负责发出去，不会管对端是否收到，若发送的时刻没有对端接收，那消息就没了，因此在广播模式下设置消息持久化是无效的。

// 三种广播模式：
// fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；
// direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；
// topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；

// RabbitMQ ...
type RabbitMQ struct {
	conn    *amqp.Connection
	channel *amqp.Channel
	// exchangeName string
}

// func (r *RabbitMQ) init(topic string) (queue amqp.Queue, err error) {
// 	err = r.channel.ExchangeDeclare(
// 		topic,    //名称
// 		"direct", //类型
// 		true,     //持久
// 		false,    //自动删除的
// 		false,    //内部
// 		false,    //无等待
// 		nil,      //参数
// 	)
// 	// queue, err = r.channel.QueueDeclare(
// 	// 	topic, // 名称
// 	// 	true,  // 持久性
// 	// 	false, // 删除未使用时
// 	// 	false, // 独有的
// 	// 	false, // 不等待
// 	// 	nil,   //参数
// 	// )
// 	return
// }

func (r *RabbitMQ) init(topic string) (err error) {
	err = r.channel.ExchangeDeclare(
		topic,    //名称
		"direct", //类型
		true,     //持久
		false,    //自动删除的
		false,    //内部
		false,    //无等待
		nil,      //参数
	)
	// queue, err = r.channel.QueueDeclare(
	// 	topic, // 名称
	// 	true,  // 持久性
	// 	false, // 删除未使用时
	// 	false, // 独有的
	// 	false, // 不等待
	// 	nil,   //参数
	// )
	return
}

//Publish ...
func (r *RabbitMQ) Publish(ctx context.Context, topic string, msg interface{}) (err error) {
	err = r.init(topic)
	if err != nil {
		return
	}
	var data []byte
	data, err = json.Marshal(msg)
	if err != nil {
		return
	}
	err = r.channel.Publish(
		topic, //交换
		"q1",  //路由密钥
		false, //强制
		false, //立即
		amqp.Publishing{
			ContentType: "application/json",
			Body:        data,
		})
	return
}

//Subscribe ...
func (r *RabbitMQ) Subscribe(topic string, h mq.SubscribeHandler, queueName ...string) (err error) {
	err = r.init(topic)
	if err != nil {
		fmt.Println("11111111111")
		return
	}
	if len(queueName) > 0 {
		// _, err = r.channel.QueueDeclare(
		// 	queueName[0], // 名称
		// 	true,         // 持久性
		// 	false,        // 删除未使用时
		// 	false,        // 独有的
		// 	false,        // 不等待
		// 	nil,          //参数
		// )
		// err = r.channel.QueueBind(
		// 	queueName[0], // 队列
		// 	queueName[0], // routing key
		// 	topic,        // 交换
		// 	false,
		// 	nil,
		// )
		// if err != nil {
		// 	fmt.Println("222222222")
		// 	return
		// }
	}
	var msgs <-chan amqp.Delivery
	msgs, err = r.channel.Consume(
		queueName[0], // 队列
		"",           // 消费者
		false,        // 自动确认
		false,        // 独有的
		false,        // no-local
		false,        // 不等待
		nil,          // 参数
	)
	if err != nil {
		return
	}
	go func() {
		for {
			select {
			case msg := <-msgs:
				if msgErr := h(context.Background(), msg.Body); msgErr == nil {
					msg.Ack(false)
				}
			}
		}
	}()
	return
}

// NewRabbitMQ ..
func NewRabbitMQ(url, exchangeName string) (rabbitmq *RabbitMQ, err error) {
	var (
		conn    *amqp.Connection
		channel *amqp.Channel
	)
	conn, err = amqp.Dial(url)
	if err != nil {
		return
	}
	channel, err = conn.Channel()
	if err != nil {
		return
	}
	rabbitmq = &RabbitMQ{
		conn:    conn,
		channel: channel,
		// exchangeName: exchangeName,
	}
	return
}
